///////////////////////////////////////////////////////////////////////////////
//Modified Guard Module
///////////////////////////////////////////////////////////////////////////////

//Defines the intent text
expression #Intent_Guard_Caravan "guarding_caravan"

//Reduce wandering distance (original SDK value is 3)
//Try different values: 1 = close, 2 = moderate, 0.5 = very close
expression #Def_Car_Wander_Mod 2

//Thread update interval for caravan following (in milliseconds)
expression #Caravan_Update_Interval 5000

//Guard Check
//////////////////////////////////////
function guard_check(agent thisagent, string whattype, string whattoguard, integer chance) is Boolean

declare
	list potentials;
	agent best_one;
	agent diddly;
	list new_potentials,guards;
	integer range;

begin
	// Check if agent still exists before proceeding
	if ($notvalid(thisagent))
		return FALSE;

	// Declare custom attribute for thread management (SDK pattern)
	$AddAttribute(thisagent, "update_thread", "function", $update_caravan_destination);

//	$debugout("Should I guard",whattoguard,"?");

	// Don't start guarding if home/realm is in danger - defense takes priority
	if ($is_in_danger(thisagent's "home", thisagent) ||
		$is_in_danger($getpalace(thisagent), thisagent))
		begin
			return FALSE;
		end

	if ($randomnumber(100) + 1 > chance)
		begin
//			$debugout("No - not interested.");
			return FALSE;
		end

	range = $getattribute(thisagent,#ATTRIB_sightrange) * 30;

	//potentials = $listtitlesinRadius(thisagent,whattype,whattoguard,range);

	// Find all caravans within range (filtered by title)
	$ListObjects (ThisAgent, WhatType, Range, Potentials, #CheckTitles, WhatToGuard);

	foreach diddly in potentials do
		begin
			// Skip if caravan no longer exists
			if ($notvalid(diddly))
				continue;

			//guards = $listtitlesinradius(diddly,"hero",thisagent's "title",range);

			if ($ListObjects (Diddly, "Hero", 1000, Guards, #CheckTitles, ThisAgent's "Title") < 3)
				new_potentials << diddly;
		end

	potentials = new_potentials;

	if ($listsize(potentials) < 1)
		begin
//			$debugout("No unguarded ",whattoguard," on map.");
			return FALSE;
		end

	 // Select random caravan from potentials (all have < 3 guards)
	 Best_One = $ListMember (Potentials, $RandomNumber($ListSize(Potentials)) + 1);
	//best_one = $pick_closest(thisagent,potentials);

	// Check if selected caravan still exists
	if ($notvalid(best_one))
		return FALSE;

  //	if ($distanceBetweenAgents(thisagent,best_one) < (10 * $getattribute(thisagent,#ATTRIB_Sightrange)))
	 //	begin
			thisagent's "Activescript" = $guard_caravan;
			thisagent's "target" = best_one;
			thisagent's "taskname" = "defending";
			thisagent's "backScript" = $guard_caravan;  // Return to defending after combat victories
			$SpecifyIntent(ThisAgent, #Intent_Guard_Caravan);
			// Start thread to periodically update destination for moving caravan (SDK pattern)
			$NewThread(thisagent's "update_thread", #Caravan_Update_Interval, thisagent);
//			best_one's "num_guards" += 1;
//			$debugout("Yes!");
			return TRUE;
	  //	end

//	$debugout("Not near enough.");
	return False;
end

// Cleanup Guard State
///////////////////////////////////////
function cleanup_guard_state(agent thisagent)
declare
begin
	// Check if agent still exists before proceeding
	if ($notvalid(thisagent))
		return;
	// Kill the update thread if it exists
	if ($hasattribute("update_thread", thisagent))
		$killthread(thisagent's "update_thread");

	// Clear guard-specific attributes to allow natural decision tree flow
	if ($hasattribute("target", thisagent))
		thisagent's "target" = $nullagent();

	if ($hasattribute("taskname", thisagent))
		thisagent's "taskname" = "";

	// Don't set any backScript - let the built-in fleeing system handle return behavior
	// The hero will resume normal decision tree behavior after fleeing completes
end

// Update Caravan Destination Thread
///////////////////////////////////////
function update_caravan_destination(agent thisagent)

declare
	agent target;

begin
	// Check if agent still exists before proceeding (critical for thread functions)
	if ($notvalid(thisagent))
		return;

	target = thisagent's "target";

	// Check if hero has started fleeing or defending home/realm - clean up and exit
	if ($GetAttribute(thisagent, #ATTRIB_AIIntentionString) == #intent_flee_scared ||
		$GetAttribute(thisagent, #ATTRIB_AIIntentionString) == #intent_flee_lowHP ||
		$GetAttribute(thisagent, #ATTRIB_AIIntentionString) == #intent_flee ||
		$GetAttribute(thisagent, #ATTRIB_AIIntentionString) == #intent_flee_map ||
		$GetAttribute(thisagent, #ATTRIB_AIIntentionString) == #intent_defending_home ||
		$GetAttribute(thisagent, #ATTRIB_AIIntentionString) == #intent_defending_palace ||
		$GetAttribute(thisagent, #ATTRIB_AIIntentionString) == #Intent_Defending_Building)
		begin
			$cleanup_guard_state(thisagent);
			return;
		end

	// Check if target is still valid
	if ($notvalid(target))
		begin
			$stopmoving(thisagent);
			$reset_tasks(thisagent);
			if ($hasattribute("update_thread", thisagent))
				$killthread(thisagent's "update_thread");
			return;
		end

	// Update destination to follow moving caravan
	thisagent's "destination" = $RandomCoord (target, $getattribute (thisagent, #ATTRIB_SightRange) * #Def_Car_Wander_Mod);
	thisagent's "backScript" = $guard_caravan;  // Return to defending after movement
	$move(thisagent, thisagent's "destination");
end

// Guard Caravan
/////////////////////////////////////////
function guard_caravan(agent thisagent)

declare

	agent target;
	integer targetrange;

begin
	// Check if agent still exists before proceeding
	if ($notvalid(thisagent))
		return;

	target = thisagent's "target";

	// Check if hero has started fleeing or defending home/realm - if so, clean up guard state
	if ($GetAttribute(thisagent, #ATTRIB_AIIntentionString) == #intent_flee_scared ||
		$GetAttribute(thisagent, #ATTRIB_AIIntentionString) == #intent_flee_lowHP ||
		$GetAttribute(thisagent, #ATTRIB_AIIntentionString) == #intent_flee ||
		$GetAttribute(thisagent, #ATTRIB_AIIntentionString) == #intent_flee_map ||
		$GetAttribute(thisagent, #ATTRIB_AIIntentionString) == #intent_defending_home ||
		$GetAttribute(thisagent, #ATTRIB_AIIntentionString) == #intent_defending_palace ||
		$GetAttribute(thisagent, #ATTRIB_AIIntentionString) == #Intent_Defending_Building)
		begin
			// Hero is fleeing or defending home/realm - clean up guard module state
			$cleanup_guard_state(thisagent);
			return;  // Exit and let built-in system handle higher priority task
		end

	// is target still valid
	if ($notvalid(target))
		begin
			$stopmoving(thisagent);
			$reset_tasks(thisagent);
			// Kill the update thread when target becomes invalid
			if ($hasattribute("update_thread", thisagent))
				$killthread(thisagent's "update_thread");
		end
	else
		begin
			// Check for enemies nearby - if found, switch to combat mode
			$list_enemies(thisagent, 1);
			if ($listsize(thisagent's "Hostiles") > 0)
				begin
					// Enemies detected - switch to attack mode with return to defending
					thisagent's "target" = $pick_closest(thisagent, thisagent's "Hostiles");
					thisagent's "activeScript" = $attack_object;
					thisagent's "backScript" = $guard_caravan;  // Return to defending after combat victory
					$SpecifyIntent(ThisAgent, #Intent_fighting);
					return;  // Exit guard_caravan to let attack_object handle combat
				end

			// is thisagent low on HP
			if ($haslowHP(thisagent))
				begin
					$heal_self(thisagent);
				end
			else
				begin
					// is thiaagent in range of target
					targetrange = $distanceBetweenAgents(thisagent,target);

					if (targetrange > ($gettargetrange(thisagent)))
						begin
							// move towards target - thread handles periodic updates
							thisagent's "destination" = $RandomCoord (Target, $getattribute (ThisAgent, #ATTRIB_SightRange) * #Def_Car_Wander_Mod);
							thisagent's "activeScript" = $travel_to;
							thisagent's "backScript" = $guard_caravan;  // Return to defending after movement
							$move(thisagent,thisagent's "destination");
						end
					else
						begin
							// At caravan location - ready to defend
							// backScript will be set above if needed
						end
				end
		end
end